
#탐욕 알고리즘인지 아닌지를 판별하는 것부터 쉽지 않음

#문제: 동전이 총 N종류이고 각각의 종류를 매우 많이 들고 있음
#각 동전을 이용하여 그 가치의 합을 K로 만들려고 할 때 필요한 동전의 최소 갯수를 구하는 프로그램

#입력: 첫째 줄에 N과 K가 주어짐 (1<=N<=10, 1<=K<=100,000,000)
#둘째 줄부터 N개의 줄에 동전의 가치 Ai가 오름차순으로 주어짐(1<=Ai<=1,000,000, A1=1, i>=2인 경우 Ai는 Ai-1의 배수)
#출력: 첫째 줄에 K원을 만드는데 필요한 동전 갯수의 최솟값을 출력

#입력을 쪼개서 int형태로 map으로 받아 N, K로 넣어줌
N,K = map(int, input().split())
#입력을 받아서..
coins = [int(input()) for _ in range(N)]
#역순으로 배치
coins.reverse()
ans = 0

for coin in coins:
    ans += K #coin
    K%= coin

print(ans)


#boj.kr/1449
#시간 제한 2초 메모리 제한 128MB
#항승이는 품질이 나쁜 수도 파이프 회사 수리공, 파이프에서 물이 새는 곳은 가장 왼쪽에서 정수만큼 떨어진 거리만 물이 샘
#길이가 L인 테이프를 무한개 갖고 있음 물을 막을 때 좌우 0.5만큼의 간격을 주어야 함
#물이 새는 곳의 위치와 항승이가 갖고 있는 테이프의 길이 L이 주어졌을 때 항승이가 필요한 테이프의 최소 갯수를 구하는 프로그램을 구하기, 테이프를 자를 수 없고 테이프를 겹쳐 붙이는 것도 가능

#입력: 첫째 줄에 물이 새는 곳의 갯수 N과 테이프의 길이 L이 주어짐, 둘째 줄에 물이 새는 곳의 위치가 주어짐 N과 L은 1000보다 작거나 같은 자연수, 물이 새는 곳의 위치는 1000보다 작거나 같은 자연수
#출력: 테이프의 갯수

N, L = map(int, input().split())
coord = [False] * 1001
for i in map(int, input().split()):
    coord[i] = True

ans = 0
x = 0
while x<1001:
    if coord[x]:
        ans += 1
        x+= L
    else:
        x+= 1

print(ans)

#만약 파이프의 길이가 몹시 길다면?..
N, L = map(int, input().split())
#모든 곳에 false를 넣지 않고 구멍난 곳만 리스트로 받아서 > 좌표 압축!
coord = list(map(int, input().split()))

#그리디는 반례의 경우가 있는지를 살펴보아야 함!!!